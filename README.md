### Step-by-step walkthrough of part 2

[/commits/part2](../../commits/part2)

### Summary of part 2

We've developed a type class that does compile-time immutability checking
via an implicit materialization macro. Again, thanks to macros, we've been
able to make it free it of any runtime overhead.

```
trait Immutable[T]
object Immutable {
  implicit def materialize[T]: Immutable[T] = macro materializeImpl[T]
}
```

### Basic macrology

  * Type class instances can be transparently generated with a special flavor of macros called materializers: [http://docs.scala-lang.org/overviews/macros/implicits.html](http://docs.scala-lang.org/overviews/macros/implicits.html).
  * The most important thing to keep in mind about materializers is that they can overflow the stack if recursion is not contained. There are several techniques to "tie the knot" preventing that, one of which is demonstrated in the accompanying code.
  * Another important thing is that materializers are currently incapable of sharing generated code. A materializer used 100 times for the same type will produce 100 copies of the same expansion. While we're fixing that, consider caching materialized instances in strategic places in your application.
  * Debugging implicit macros is harder than debugging regular def macros. Errors generated by whitebox implicit macros aren't shown by the compiler unless `-Xlog-implicits` is enabled. We are working on that.
  * Speaking of boxity, it works a bit differently in the implicit setting. See [http://docs.scala-lang.org/overviews/macros/blackbox-whitebox.html](http://docs.scala-lang.org/overviews/macros/blackbox-whitebox.html) for information on the blackbox/whitebox separation.
  * Materialization for variant type classes behaves funnily, but there's a simple workaround that provides a fix. Look up one of the later commits in history to see this in action.

### Basic reflection

  * Symbols represents members, and types represent types. Symbols are mostly used to check flags and introspect signatures. Types are typically used to obtain lists of members and do subtyping checks.
  * There's a difference between a type-representing `Tree` (produced by `tq"..."`) and a `Type`. The former is a syntactic precursor of the latter and has to be converted to a `Type` before performing any semantic operation (subtyping checks, implicit inference, etc). In order to do the conversion, go for `c.typecheck(..., c.TYPEmode)`. `appliedType` also works, but it's often not enough.
  * `Symbol.typeSignature` goes from a member to its type signature. There's also `Symbol.typeSignatureIn` that additionally takes a type corresponding to the declaring class/trait/object and substitutes all type parameters in symbol's type signature with type arguments inferred from the provided type.
  * `Type.typeSymbol` goes from a type to an accompanying symbol. It returns a `ClassSymbol` if the type refers to a class, a trait or a module (so called module class) or a `TypeSymbol` if the type refers to a type member or a type parameter. Don't blindly do `typeSymbol.asClass`, because it might crash.
  * `ClassSymbol.knownDirectSubclasses` is a powerful API that lets you reason about children of a given sealed class but it's quite flaky and might not work correctly in certain situations (see [SI-7755](https://issues.scala-lang.org/browse/SI-7755)). Even though the bug was closed as wont-fix, we have some ideas how we could address it in the future.
  * Intrinsic types might look differently from regular types from the point of view of reflection. Make sure your code handles such corner cases properly.

### The end

This concludes the workshop. Thanks for your participation and see you later!
